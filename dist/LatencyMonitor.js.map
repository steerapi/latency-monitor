{"version":3,"sources":["LatencyMonitor.js"],"names":["debug","require","LatencyMonitor","latencyCheckIntervalMs","dataEmitIntervalMs","asyncTestFn","latencyRandomPercentage","that","_latecyCheckMultiply","_latecyCheckSubtract","undefined","process","hrtime","now","getDeltaMS","startTime","window","performance","bind","Math","round","Date","_latencyData","_initLatencyData","_startTimers","_emitSummary","_stopTimers","_checkLatencyID","_checkLatency","_emitIntervalID","setInterval","unref","clearTimeout","clearInterval","summary","getSummary","events","emit","latency","minMs","maxMs","avgMs","totalMs","Number","POSITIVE_INFINITY","lengthMs","randomness","random","localData","deltaOffset","ceil","cb","value","deltaMS","min","max","setTimeout","NEGATIVE_INFINITY","EventEmitter"],"mappings":"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","file":"LatencyMonitor.js","sourcesContent":["/* global window */\nimport EventEmitter from 'events';\nimport lodashGet from 'lodash/get';\nimport isFunction from 'lodash/isFunction';\n// import VisibilityChangeEmitter from './VisibilityChangeEmitter';\n\nconst debug = require('debug')('latency-monitor:LatencyMonitor');\n\n/**\n * @typedef {Object} SummaryObject\n * @property {Number} events How many events were called\n * @property {Number} minMS What was the min time for a cb to be called\n * @property {Number} maxMS What was the max time for a cb to be called\n * @property {Number} avgMs What was the average time for a cb to be called\n * @property {Number} lengthMs How long this interval was in ms\n */\n\n/**\n * A class to monitor latency of any async function which works in a browser or node. This works by periodically calling\n * the asyncTestFn and timing how long it takes the callback to be called. It can also periodically emit stats about this.\n * This can be disabled and stats can be pulled via setting dataEmitIntervalMs = 0.\n *\n * The default implementation is an event loop latency monitor. This works by firing periodic events into the event loop\n * and timing how long it takes to get back.\n *\n * @example\n * const monitor = new LatencyMonitor();\n * monitor.on('data', (summary) => console.log('Event Loop Latency: %O', summary));\n *\n * @example\n * const monitor = new LatencyMonitor({latencyCheckIntervalMs: 1000, dataEmitIntervalMs: 60000, asyncTestFn:ping});\n * monitor.on('data', (summary) => console.log('Ping Pong Latency: %O', summary));\n */\nclass LatencyMonitor extends EventEmitter {\n  /**\n   * @param {Number} [latencyCheckIntervalMs=500] How often to add a latency check event (ms)\n   * @param {Number} [dataEmitIntervalMs=5000] How often to summarize latency check events. null or 0 disables event firing\n   * @param {function} [asyncTestFn] What cb-style async function to use\n   * @param {Number} [latencyRandomPercentage=5] What percent (+/-) of latencyCheckIntervalMs should we randomly use? This helps avoid alignment to other events.\n   */\n  constructor({\n    latencyCheckIntervalMs,\n    dataEmitIntervalMs,\n    asyncTestFn,\n    latencyRandomPercentage\n  } = {}) {\n    super();\n    const that = this;\n\n    // 0 isn't valid here, so its ok to use ||\n    that.latencyCheckIntervalMs = latencyCheckIntervalMs || 500; // 0.5s\n    that.latencyRandomPercentage = latencyRandomPercentage || 10;\n    that._latecyCheckMultiply =\n      2 * (that.latencyRandomPercentage / 100.0) * that.latencyCheckIntervalMs;\n    that._latecyCheckSubtract = that._latecyCheckMultiply / 2;\n\n    that.dataEmitIntervalMs =\n      dataEmitIntervalMs === null || dataEmitIntervalMs === 0\n        ? undefined\n        : dataEmitIntervalMs || 5 * 1000; // 5s\n    debug(\n      'latencyCheckIntervalMs: %s dataEmitIntervalMs: %s',\n      that.latencyCheckIntervalMs,\n      that.dataEmitIntervalMs\n    );\n    if (that.dataEmitIntervalMs) {\n      debug(\n        'Expecting ~%s events per summary',\n        that.latencyCheckIntervalMs / that.dataEmitIntervalMs\n      );\n    } else {\n      debug('Not emitting summaries');\n    }\n\n    that.asyncTestFn = asyncTestFn; // If there is no asyncFn, we measure latency\n\n    // If process: use high resolution timer\n    if (process && process.hrtime) {\n      debug('Using process.hrtime for timing');\n      that.now = process.hrtime;\n      that.getDeltaMS = (startTime) => {\n        const hrtime = that.now(startTime);\n        return hrtime[0] * 1000 + hrtime[1] / 1000000;\n      };\n      // Let's try for a timer that only monotonically increases\n    } else if (typeof window !== 'undefined' && lodashGet(window, 'performance.now')) {\n      debug('Using performance.now for timing');\n      that.now = window.performance.now.bind(window.performance);\n      that.getDeltaMS = (startTime) => Math.round(that.now() - startTime);\n    } else {\n      debug('Using Date.now for timing');\n      that.now = Date.now;\n      that.getDeltaMS = (startTime) => that.now() - startTime;\n    }\n\n    that._latencyData = that._initLatencyData();\n\n    // We check for isBrowser because of browsers set max rates of timeouts when a page is hidden,\n    // so we fall back to another library\n    // See: http://stackoverflow.com/questions/6032429/chrome-timeouts-interval-suspended-in-background-tabs\n    // if (isBrowser()) {\n    // \tthat._visibilityChangeEmitter = new VisibilityChangeEmitter();\n    // \tthat._visibilityChangeEmitter.on('visibilityChange', (pageInFocus) => {\n    // \t\tif (pageInFocus) {\n    // \t\t\tthat._startTimers();\n    // \t\t} else {\n    // \t\t\tthat._emitSummary();\n    // \t\t\tthat._stopTimers();\n    // \t\t}\n    // \t});\n    // }\n\n    // if (!that._visibilityChangeEmitter || that._visibilityChangeEmitter.isVisible()) {\n    // \tthat._startTimers();\n    // }\n  }\n\n  start() {\n    this._startTimers();\n  }\n\n  stop() {\n    this._emitSummary();\n    this._stopTimers();\n  }\n\n  /**\n   * Start internal timers\n   * @private\n   */\n  _startTimers() {\n    // Timer already started, ignore this\n    if (this._checkLatencyID) {\n      return;\n    }\n    this._checkLatency();\n    if (this.dataEmitIntervalMs) {\n      this._emitIntervalID = setInterval(() => this._emitSummary(), this.dataEmitIntervalMs);\n      if (isFunction(this._emitIntervalID.unref)) {\n        this._emitIntervalID.unref(); // Doesn't block exit\n      }\n    }\n  }\n\n  /**\n   * Stop internal timers\n   * @private\n   */\n  _stopTimers() {\n    if (this._checkLatencyID) {\n      clearTimeout(this._checkLatencyID);\n      this._checkLatencyID = undefined;\n    }\n    if (this._emitIntervalID) {\n      clearInterval(this._emitIntervalID);\n      this._emitIntervalID = undefined;\n    }\n  }\n\n  /**\n   * Emit summary only if there were events. It might not have any events if it was forced via a page hidden/show\n   * @private\n   */\n  _emitSummary() {\n    const summary = this.getSummary();\n    if (summary.events > 0) {\n      this.emit('data', summary);\n    }\n  }\n\n  /**\n   * Calling this function will end the collection period. If a timing event was already fired and somewhere in the queue,\n   * it will not count for this time period\n   * @returns {SummaryObject}\n   */\n  getSummary() {\n    // We might want to adjust for the number of expected events\n    // Example: first 1 event it comes back, then such a long blocker that the next emit check comes\n    // Then this fires - looks like no latency!!\n    const latency = {\n      events: this._latencyData.events,\n      minMs: this._latencyData.minMs,\n      maxMs: this._latencyData.maxMs,\n      avgMs: this._latencyData.events\n        ? this._latencyData.totalMs / this._latencyData.events\n        : Number.POSITIVE_INFINITY,\n      lengthMs: this.getDeltaMS(this._latencyData.startTime)\n    };\n    this._latencyData = this._initLatencyData(); // Clear\n\n    debug('Summary: %O', latency);\n    return latency;\n  }\n\n  /**\n   * Randomly calls an async fn every roughly latencyCheckIntervalMs (plus some randomness). If no async fn is found,\n   * it will simply report on event loop latency.\n   *\n   * @private\n   */\n  _checkLatency() {\n    const that = this;\n    // Randomness is needed to avoid alignment by accident to regular things in the event loop\n    const randomness = Math.random() * that._latecyCheckMultiply - that._latecyCheckSubtract;\n\n    // We use this to ensure that in case some overlap somehow, we don't take the wrong startTime/offset\n    const localData = {\n      deltaOffset: Math.ceil(that.latencyCheckIntervalMs + randomness),\n      startTime: that.now()\n    };\n\n    const cb = (value) => {\n      // We are already stopped, ignore this datapoint\n      if (!this._checkLatencyID) {\n        return;\n      }\n\n      const deltaMS = value;\n      that._checkLatency(); // Start again ASAP\n\n      // Add the data point. If this gets complex, refactor it\n      that._latencyData.events++;\n      that._latencyData.minMs = Math.min(that._latencyData.minMs, deltaMS);\n      that._latencyData.maxMs = Math.max(that._latencyData.maxMs, deltaMS);\n      that._latencyData.totalMs += deltaMS;\n      debug('MS: %s Data: %O', deltaMS, that._latencyData);\n    };\n    debug('localData: %O', localData);\n\n    this._checkLatencyID = setTimeout(() => {\n      // This gets rid of including event loop\n      if (that.asyncTestFn) {\n        // Clear timing related things\n        localData.deltaOffset = 0;\n        localData.startTime = that.now();\n        that.asyncTestFn(cb);\n      } else {\n        // setTimeout is not more accurate than 1ms, so this will ensure positive numbers. Add 1 to emitted data to remove.\n        // This is not the best, but for now it'll be just fine. This isn't meant to be sub ms accurate.\n        localData.deltaOffset -= 1;\n        // If there is no function to test, we mean check latency which is a special case that is really cb => cb()\n        // We avoid that for the few extra function all overheads. Also, we want to keep the timers different\n        const deltaMS = that.getDeltaMS(localData.startTime) - localData.deltaOffset;\n        cb(deltaMS);\n      }\n    }, localData.deltaOffset);\n\n    if (isFunction(this._checkLatencyID.unref)) {\n      this._checkLatencyID.unref(); // Doesn't block exit\n    }\n  }\n\n  _initLatencyData() {\n    return {\n      startTime: this.now(),\n      minMs: Number.POSITIVE_INFINITY,\n      maxMs: Number.NEGATIVE_INFINITY,\n      events: 0,\n      totalMs: 0\n    };\n  }\n}\n\n// function isBrowser() {\n// \treturn typeof window !== 'undefined';\n// }\n\nexport default LatencyMonitor;\n"]}